hld <- merge(rwm$data, rwm$annotate, by=0)
hld <- hld[order(hld$chromosome, hld$start),]
cvec <- hld[,grepl("chromosome", colnames(hld))]
cvec <- cvec %in% env$input[[p("choosechr")]]
hld <- hld[cvec,]
rownames(hld) <- hld$Row.names
#Truncate names for neatness
rownames(hld) <- substr(rownames(hld), 1, 17)
hld$product <- substr(hld$product, 1, 76)
hld$gene <- substr(hld$gene, 1, 11)
#Remove row.names column
hld$Row.names <- NULL
return(hld)
})
return(proc())
}
server <- function(env) {
env$output[[p("chrs")]] <- shiny::renderUI({
tmpvec <- levels(rw$Annotation$chromosome)
selectizeInput("choosechr", "Choose chromosomes to display",multiple=T,tmpvec, selected=tmpvec)
})
env[[p("grob")]] <- reactive({
a1 <- wproc(env)
tvec <- grepl("Tail|Count", colnames(a1))
y <- ensure_reactable(a1[,tvec])
n <- env$input[[p("n")]]
if (n > 2000) stop("Drawing large heatmaps uses excessive system resources. Sorry.")
y_val <- as.matrix(y(env))
y_span <- apply(y_val,1,max) - apply(y_val,1,min)
selection <- rep(FALSE,nrow(y_val))
selection[ order(-y_span)[ seq_len(n) ] ] <- TRUE
if (sum(selection) < 1) stop("No features to show.")
pl_hmap_detailed(
matf=y_val[selection,,drop=FALSE],
gmatf=a1[!tvec][selection,,drop=FALSE],
sample_labels=sample_labels(env),
sample_labels2=sample_labels(env),
feature_labels=feature_labels(env)[selection],
clusterby=env$input[[p("Clusterby")]],
cluster_features=env$input[[p("seqGroup")]],
feat_span=env$input[[p("featspan")]]
)
})
plot$component_server(env)
}
composable_shiny_app(ui, server)
}
sh_hmap_detailed((A))
rm(list=ls())
library(devtools)
install_github("MonashBioinformaticsPlatform/varistran")
#Currently takes a read.grouped.table list from counts.csv
#read.grouped.table comes from the nesoni package
#vst comes from varistran which this depends on
# -Assumes there exists Annotate, Counts, Tail, Tail_counts    p dataframes.
# -Missing one of the above will cause crash
sh_hmap_detailed <- function(rw, sample_labels=NULL, sample_labels2=NULL, feature_labels=NULL, prefix="") {
p <- function(name) paste0(prefix,name)
sample_labels <- ensure_reactable(sample_labels)
sample_labels2 <- ensure_reactable(sample_labels2)
feature_labels <- ensure_reactable(feature_labels)
plot <- shiny_plot(
callback = function(env) {
print(env[[p("grob")]]())
},
width=1250,
height=900,
dlname="heatmap",
prefix=p("plot_")
)
ui <- shiny::tags$div(
shiny::titlePanel("Heatmap"),
shiny::p("Features are selected based on span of:"),
shiny::radioButtons(p("featspan"),
label="Expression or Tail length",
choices=list("Expression"=2, "Tail Length"=1),
selected=1,
inline=TRUE),
shiny::uiOutput(p("chrs")),
shiny::numericInput(p("n"), "Number of features to show", 50, min=10,max=2000,step=10),
shiny::numericInput(p("nmin"), "Trim low Tail_count to NA", 10, min=0,max=1000,step=1),
shiny::radioButtons(p("seqGroup"),
label="Cluster/Group options",
choices=list("Cluster by row"=1, "Group by location"=2),
selected=1,
inline=TRUE),
shiny::radioButtons("Clusterby",
label="Cluster by samples: ",
choices=list("None" = 1, "Tail length" = 2, "Expression" = 3),
selected = 1,
inline=TRUE),
plot$component_ui,
parenthetically("This plot is produced by a modified varistran::plot_heatmap.")
)
#Processes the input list into a single dataframe with annotation and count data
wproc <- function(env){
proc <- reactive({
rw2 <- list()
rw$Tail[rw$Tail_count < env$input[[p("nmin")]]] = NA
rw2$Tail <- rw$Tail
rw2$Count <- rw$Count
#Append names to grep out
colnames(rw2$Tail) <- paste(colnames(rw2$Tail), "Tail")
colnames(rw2$Count) <- paste(colnames(rw2$Count), "Count")
rw3 <- list()
rw3$Tail <- rw2$Tail
rw3$Count <- varistran::vst(rw2$Count)
rwm <- list()
rwm$data <- merge(rw3$Tail, rw3$Count, by=0)
rownames(rwm$data) <- rwm$data$Row.names
rwm$annotate<- rw$Annotation[rownames(rw$Annotation) %in% rwm$data$Row.names,]
ra <- rw$Tail_count[rownames(rw$Tail_count) %in% rwm$data$Row.names,]
colnames(ra) <- paste(colnames(ra), "tc")
rwm$data$Row.names <- NULL
#Sort into order
hld <- merge(rwm$data, rwm$annotate, by=0)
hld <- hld[order(hld$chromosome, hld$start),]
cvec <- hld[,grepl("chromosome", colnames(hld))]
cvec <- cvec %in% env$input[[p("choosechr")]]
hld <- hld[cvec,]
rownames(hld) <- hld$Row.names
#Truncate names for neatness
rownames(hld) <- substr(rownames(hld), 1, 17)
hld$product <- substr(hld$product, 1, 76)
hld$gene <- substr(hld$gene, 1, 11)
#Remove row.names column
hld$Row.names <- NULL
return(hld)
})
return(proc())
}
server <- function(env) {
env$output[[p("chrs")]] <- shiny::renderUI({
tmpvec <- levels(rw$Annotation$chromosome)
selectizeInput("choosechr", "Choose chromosomes to display",multiple=T,tmpvec, selected=tmpvec)
})
env[[p("grob")]] <- reactive({
a1 <- wproc(env)
tvec <- grepl("Tail|Count", colnames(a1))
y <- ensure_reactable(a1[,tvec])
n <- env$input[[p("n")]]
if (n > 2000) stop("Drawing large heatmaps uses excessive system resources. Sorry.")
y_val <- as.matrix(y(env))
y_span <- apply(y_val,1,max) - apply(y_val,1,min)
selection <- rep(FALSE,nrow(y_val))
selection[ order(-y_span)[ seq_len(n) ] ] <- TRUE
if (sum(selection) < 1) stop("No features to show.")
pl_hmap_detailed(
matf=y_val[selection,,drop=FALSE],
gmatf=a1[!tvec][selection,,drop=FALSE],
sample_labels=sample_labels(env),
sample_labels2=sample_labels(env),
feature_labels=feature_labels(env)[selection],
clusterby=env$input[[p("Clusterby")]],
cluster_features=env$input[[p("seqGroup")]],
feat_span=env$input[[p("featspan")]]
)
})
plot$component_server(env)
}
composable_shiny_app(ui, server)
}
#' Plot a heatmap.
#'
#' Produces a heatmap as a grid grob.
#'
#' Clustering is performed using the "seriation" package, and is approximately a Travelling Salesman Problem ordering. If there are many features (more than a couple of thousand) clustering may be slow.
#'
#' @param y A matrix of expression levels, such as a transformed counts matrix.
#' @param clusterby How samples are clustered, Includes None
#' @param cluster_features Should features (rows) be clustered?
#' @param sample_labels Names for each sample. If not given and y has column names, these will be used instead.
#' @param feature_labels Names for each feature. If not given and y has row names, these will be used instead.
#'
#' @return A grid grob. print()-ing this value will cause it to be displayed.
#'
#' Additionally $info$row_order will contain row ordering and $info$col_order will contain column ordering.
#' @author Paul Harrison.
#' @author Michael See
#'
#' @export
pl_hmap_detailed <- function(
matf,
gmatf,
clusterby=1,
cluster_features=1,
sample_labels=NULL,
sample_labels2=NULL,
feature_labels=NULL,
gene_labels=NULL,
product_labels=NULL,
feat_span=1
) {
matf <- as.data.frame(matf)
tvec <- grepl("Tail", colnames(matf))
#     matf <- data.frame(matf[apply(matf[,!tvec],1,function(row) {
#         any(row >= log2(nmin))
#     }),])
y <- as.matrix(matf[,tvec])
z <- as.matrix(matf[,!tvec])
if (is.null(sample_labels) && !is.null(colnames(y)))
sample_labels <- colnames(y)
if (is.null(sample_labels))
sample_labels <- rep("", ncol(y))
sample_labels[is.na(sample_labels)] <- ""
#Repeat for heatmap2
if (is.null(sample_labels2) && !is.null(colnames(z)))
sample_labels2 <- colnames(z)
if (is.null(sample_labels2))
sample_labels2 <- rep("", ncol(z))
sample_labels[is.na(sample_labels)] <- ""
#Labels ---
if (is.null(feature_labels) && !is.null(rownames(y)))
feature_labels <- rownames(y)
if (is.null(gene_labels) && !is.null(gmatf$gene))
gene_labels <- gmatf$gene
if (is.null(product_labels) && !is.null(gmatf$product))
product_labels <- gmatf$product
if (is.null(feature_labels))
feature_labels <- rep("", nrow(y))
if (is.null(gene_labels))
gene_labels <- rep("", nrow(y))
if (!is.null(gmatf$chromosome))
chrom_labels <- gmatf$chromosome
if (is.null(product_labels))
product_labels <- rep("", nrow(y))
feature_labels[is.na(feature_labels)] <- ""
gene_labels[is.na(feature_labels)] <- ""
product_labels[is.na(feature_labels)] <- ""
#---
means <- rowMeans(y, na.rm = TRUE)
means[is.nan(means)] = 0
y_centered <- y - means
means2 <- rowMeans(z, na.rm = TRUE)
means2[is.nan(means2)] = 0
z_centered <- z - means2
if(cluster_features==1){
cf <- TRUE
} else {
cf <- FALSE
}
if(feat_span==1){
y_scaled <- y_centered / sqrt(rowMeans(y_centered*y_centered, na.rm = TRUE))
row_order <- make_o(y_scaled, enable=cf)
} else if (feat_span==2){
z_scaled <- z_centered / sqrt(rowMeans(z_centered*z_centered, na.rm = TRUE))
row_order <- make_o(z_scaled, enable=cf)
}
cluster_samples <- FALSE
if(clusterby == 1){
col_order <- make_o(t(y_centered), enable=cluster_samples)
} else if(clusterby == 2){
cluster_samples <- TRUE
col_order <- make_o(t(y_centered), enable=cluster_samples)
} else if(clusterby == 3){
cluster_samples <- TRUE
col_order <- make_o(t(z_centered), enable=cluster_samples)
}
pad <- 0.25
row_ordering_grob <- ordering_grob(row_order, transpose=TRUE, mirror=TRUE)
col_ordering_grob <- ordering_grob(col_order)
#Heatmap 1 (Tail lenght)
heatmap <- heatmap_grob(
y_centered[row_order$order,col_order$order,drop=F],
signed=TRUE,
legend_title=paste0("difference from\nrow mean"))
#Heatmap 2 (RPM)
heatmap2 <- heatmap_grob(
z_centered[row_order$order,col_order$order,drop=F],
signed=TRUE,
legend_title=paste0("difference from\nrow mean"))
mean_range <- range(means)
if(is.na(mean_range[1]))
mean_range[1] <- 0.1
if(is.na(mean_range[2]))
mean_range[2] <- 0.1
if (mean_range[2] == mean_range[1]) mean_range[2] <- mean_range[2]+1
mean_range2 <- range(means2)
if(is.na(mean_range2[1]))
mean_range2[1] <- 0.1
if(is.na(mean_range2[2]))
mean_range2[2] <- 0.1
if (mean_range2[2] == mean_range2[1]) mean_range2[2] <- mean_range2[2]+1
#Row mean graph-1
mean_graph <- rectGrob(
x=rep(mean_range[1],nrow(y)),
y=seq_len(nrow(y))-1,
width=means[row_order$order]-mean_range[1],
height=rep(1,nrow(y)),
just=c(0,0),
default.units="native",
vp=viewport(xscale=mean_range,yscale=c(0,nrow(y)))
)
#Row mean label-1
mean_axis <- xaxisGrob(
at=axisTicks(mean_range,log=FALSE,nint=3),
label=TRUE,
vp=viewport(width=1,height=0,y=1,xscale=mean_range),
gp=gpar(cex=0.75)
)
#Row mean graph-2
mean_graph2 <- rectGrob(
x=rep(mean_range2[1],nrow(z)),
y=seq_len(nrow(z))-1,
width=means2[row_order$order]-mean_range2[1],
height=rep(1,nrow(z)),
just=c(0,0),
default.units="native",
vp=viewport(xscale=mean_range2,yscale=c(0,nrow(z)))
)
#Row mean label-2
mean_axis2 <- xaxisGrob(
at=axisTicks(mean_range2,log=FALSE,nint=3),
label=TRUE,
vp=viewport(width=1,height=0,y=1,xscale=mean_range2),
gp=gpar(cex=0.75)
)
#Row mean label
mean_label <- textGrob("row\nmean")
#Row Name column
feature_label_grob <- shrinktext_grob(
feature_labels[row_order$order],
x=rep(0,nrow(y)),
y=seq_len(nrow(y))-0.5,
just=c(0,0.5),
vp=viewport(xscale=c(0,1),yscale=c(0,nrow(y)))
)
gene_label_grob <- shrinktext_grob(
gene_labels[row_order$order],
x=rep(0,nrow(y)),
y=seq_len(nrow(y))-0.5,
just=c(0,0.5),
vp=viewport(xscale=c(0,1),yscale=c(0,nrow(y)))
)
product_label_grob <- shrinktext_grob(
product_labels[row_order$order],
x=rep(0,nrow(y)),
y=seq_len(nrow(y))-0.5,
just=c(0,0.5),
vp=viewport(xscale=c(0,1),yscale=c(0,nrow(y)))
)
chrom_label_grob <- shrinktext_grob(
chrom_labels[row_order$order],
x=rep(0,nrow(y)),
y=seq_len(nrow(y))-0.5,
just=c(0,0.5),
vp=viewport(xscale=c(0,1),yscale=c(0,nrow(y)))
)
#Heatmap 1 column name
sample_label_grob <- vertical_shrinktext_grob(
sample_labels[col_order$order],
x=seq_len(ncol(y))-0.5,
y=rep(1,ncol(y)),
just=c(1,0.5),
vp=viewport(xscale=c(0,ncol(y)),yscale=c(0,1))
)
#Heatmap 2 column name
sample_label_grob2 <- vertical_shrinktext_grob(
sample_labels2[col_order$order],
x=seq_len(ncol(z))-0.5,
y=rep(1,ncol(z)),
just=c(1,0.5),
vp=viewport(xscale=c(0,ncol(z)),yscale=c(0,1))
)
frame <- frameGrob(layout=grid.layout(nrow=4,ncol=9))
#Clustering sample dendrogram
frame <- packGrob(frame, varistran_grob(col_ordering_grob,height="inherit",pad=pad), row=1,col=2)
frame <- packGrob(frame, varistran_grob(col_ordering_grob,height="inherit",pad=pad), row=1,col=4)
#Text Labels
lab1 <- textGrob("Mean tail length")
lab2 <- textGrob("Expression")
lab3 <- textGrob("Gene Name")
lab4 <- textGrob("Row Name")
lab5 <- textGrob("Product Name")
lab6 <- textGrob("Chr")
if(cluster_samples==FALSE){
frame <- packGrob(frame, varistran_grob(lab1,height="inherit",pad=pad), row=1,col=2)
frame <- packGrob(frame, varistran_grob(lab2,height="inherit",pad=pad), row=1,col=4)
}
frame <- packGrob(frame, varistran_grob(lab3,height="inherit",pad=pad), row=1,col=6)
frame <- packGrob(frame, varistran_grob(lab4,height="inherit",pad=pad), row=1,col=8)
frame <- packGrob(frame, varistran_grob(lab5,height="inherit",pad=pad), row=1,col=9)
#Row mean heading-1
frame <- packGrob(frame, varistran_grob(mean_label,height="inherit",pad=pad), row=1,col=3)
#Dendrogram/Chromosome label
frame <- packGrob(frame, varistran_grob(row_ordering_grob,width="inherit",pad=pad), row=2,col=1)
frame <- packGrob(frame, varistran_grob(chrom_label_grob,width="inherit",pad=pad), row=2,col=7)
frame <- packGrob(frame, varistran_grob(lab6,height="inherit",pad=pad),row=1,col=7)
#Heatmap graphic-1
frame <- packGrob(frame, varistran_grob(heatmap$heatmap,pad=pad), row=2, col=2)
#Heatmap graphic-2
frame <- packGrob(frame, varistran_grob(heatmap2$heatmap,pad=pad), row=2, col=4)
#Needs its own rowmeans graph-2
frame <- packGrob(frame, varistran_grob(mean_graph2,width=unit(3,"lines"),pad=pad), row=2,col=5)
#Heatmap column names-2
frame <- packGrob(frame, varistran_grob(sample_label_grob2,height="inherit",pad=pad), row=3,col=4)
#Row mean heading-2
frame <- packGrob(frame, varistran_grob(mean_label,height="inherit",pad=pad), row=1,col=5)
#Rowmean Scale-2
frame <- packGrob(frame, varistran_grob(mean_axis2,height=unit(3,"lines"),pad=pad), row=3,col=5)
#Rowmeans-1
frame <- packGrob(frame, varistran_grob(mean_graph,width=unit(3,"lines"),pad=pad), row=2,col=3)
#Name column
frame <- packGrob(frame, varistran_grob(feature_label_grob,width="inherit",pad=pad), row=2,col=8)
#Gene column
frame <- packGrob(frame, varistran_grob(gene_label_grob,width="inherit",pad=pad), row=2,col=6)
#Product column
frame <- packGrob(frame, varistran_grob(product_label_grob,width="inherit",pad=pad), row=2,col=9)
#Heatmap column names-1
frame <- packGrob(frame, varistran_grob(sample_label_grob,height="inherit",pad=pad), row=3,col=2)
#Rowmean Scale
frame <- packGrob(frame, varistran_grob(mean_axis,height=unit(3,"lines"),pad=pad), row=3,col=3)
#Heatmap Legends
frame <- packGrob(frame, varistran_grob(heatmap$legend,height="inherit",pad=pad), row=4, col=3)
frame <- packGrob(frame, varistran_grob(heatmap2$legend,height="inherit",pad=pad), row=4, col=5)
#     frame <- packGrob(frame, varistran_grob(heatmap$legend,height="inherit",pad=pad), row=4, col=3)
outer <- frameGrob()
outer <- packGrob(outer, varistran_grob(frame), row=1,col=1)
result <- varistran_grob(outer, pad=pad)
result$info <- list(
row_order=row_order,
col_order=col_order
)
result
}
make_o <- function(mat, enable=TRUE, fast=FALSE) {
# Note: paths are given ordered by order
mat[is.na(mat)] = 0.001
if (nrow(mat) < 3 || !enable) {
list(
dendrogram = NULL,
order = seq_len(nrow(mat)),
paths = rep('',nrow(mat)))
} else if (fast) {
# Too many for seriation to deal with efficiently
perm <- seriation::seriate(mat, method='PCA')[[1]]
list(dendrogram = NULL,
order = seriation::get_order(perm),
paths = rep('',nrow(mat)))
} else {
dist_mat <- dist(mat)
control <- list(hclust = hclust(dist_mat))
dend_mat <- as.dendrogram(
seriation::seriate(dist_mat,
method = 'OLO',
control = control)[[1]])
list(dendrogram = dend_mat,
order = order.dendrogram(dend_mat),
paths = dendrogram_paths(dend_mat))
}
}
read.grouped.table("counts1.csv")
A <- read.grouped.table("counts1.csv")
sh_hmap_detailed(A)
rm(A)
package.skeleton()
roxygen2::namespace_roclet()
?roxygen2::namespace_roclet()
?roxygen2::namespace_roclet
roxygen2::namespace_roclet()
roxygen2::namespace_roclet(man/*.Rd)
roxygen2::roxygenize()
setwd("C:/Users/Michael/Dropbox/Uni/2015 - Summer/anRpackage")
setwd("C:/Users/Michael/Dropbox/Uni/2015 - Summer/anRpackage")
roxygen2::roxygenize()
roxygen2::roxygenize()
setwd("C:/Users/Michael/Dropbox/Uni/2015 - Summer")
install.packages("", repos = NULL, type="source")
setwd("C:/Users/Michael/Dropbox/Uni/2015 - Summer/hmapextension")
install.packages(C:/Users/Michael/Dropbox/Uni/2015 - Summer/hmapextension, repos = NULL, type="source")
install.packages("C:/Users/Michael/Dropbox/Uni/2015 - Summer/hmapextension", repos = NULL, type="source")
install.packages("C:/Users/Michael/Dropbox/Uni/2015 - Summer/hmapextension", repos = NULL, type="source")
library(devtools)
install_github("Monash-RNA-Systems-Biology-Laboratory/patseqers/tree/master/mmsee")
install_github("https://github.com/Monash-RNA-Systems-Biology-Laboratory/patseqers/tree/master/mmsee/hmapextension")
install_github("https://github.com/Monash-RNA-Systems-Biology-Laboratory/patseqers/tree/master/mmsee/hmapextension")
install_github("patseqers/mmsee/hmapextension/")
install_github("Monash-RNA-Systems-Biology-Laboratory/patseqers/tree/master/mmsee/hmapextension")
R CMD BUILD hmapextension
Rtools
install.packages(Rtools)
setwd(..)
setwd("..")
setwd("..")
install("hmapextension")
setwd("C:/Users/Michael/Dropbox/Uni/2015 - Summer")
install("hmapextension")
install("hmapextension")
install("hmapextension")
library(roxygen2)
setwd("..")
wd
setwd("C:/Users/Michael/Dropbox/Uni/2015 - Summer/hmapextension")
document()
setwd("..")
install("hmapextension")
install("hmapextension")
rm(list=ls())
setwd("C:/Users/Michael/Dropbox/Uni/2015 - Summer")
library(nesoni)
A <- read.grouped.table("counts1")
setwd("C:/Users/Michael/Dropbox/Uni/2015 - Summer")
A <- read.grouped.table("counts1.csv")
hmapextension::sh_hmap_detailed(A)
remove.packages(hmapexension))
remove.packages(hmapexension)
remove.packages(hmapextension)
remove.packages(hmapextension::)
install_github("patseqers/mmsee/hmapextension")
install_github("Monash-RNA-Systems-Biology-Laboratory/patseqers/mmsee/hmapextension")
install_github("Monash-RNA-Systems-Biology-Laboratory/patseqers/mmsee/hmapextension")
setwd("~/GitHub/patseqers/mmsee/hmapextension/R")
