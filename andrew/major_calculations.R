#File paths in place for when Michael directs me. 
gff_file_path <- "/home/bigpatto2/Bioinformatics/SCP_2.0/SHINY_yeast_test/"
bam_file_path <- "/home/bigpatto2/Bioinformatics/SCP_2.0/SHINY_yeast_test/"

#List all datasets inside a directories with "SHINY" in the name. 

list_datasets <- function(){
  return(c("Yeast", "Cancer"))
}

# Returns a list of bam files from the nominated directory
find_bam_files <- function(file_path) {
  bam_files <- list.files(paste (file_path), pattern = '*.bam$')
  return(bam_files)
}
# Returns a list of gff files from the nominated directory
find_gff_files <- function(file_path) {
  gff_files <- list.files(paste(file_path), pattern = '*.gff$')
  return(gff_files)
}

make_plot <- function(){
  x <- 1:10
  y<- 1:10
  return(plot(x,y))
}

selected_data<- function (data){
  return (paste(data))
}
# Outpus the rows matching the input gene or peak name   
filter_gff_for_rows<- function (gff_file,names){
    gff <- read.delim(gff_file, header=FALSE, comment.char="", stringsAsFactors=F)
    colnames(gff) <- c('Chromosome', 'Generated By', 'Feature Type', 'Peak Start',
                       'Peak End','-','Orientation', '--','Information')
    split_names <- strsplit(names, split = " ")
    print(split_names)
    empty <- data.frame()
    
    for (name in split_names[[1]]){
      index1 <- with(gff, grepl 
                     (ignore.case = T,paste('=',name,'[;/$]{1}',sep=""), gff[,'Information']))
      # Would be nice to find some better regex to get rid of this if statement. 
      # Maybe do this with a GFF parser
      
      if (sum(index1)==0){
        index1 <- with(gff, grepl 
                       (ignore.case = T,paste('=',name,'$',sep=""), gff[,'Information']))
      }
      
      output <-gff[index1, ] 
      empty <- rbind(empty, output)
    }
    return(empty)
}

# This function gets the poly (A) counts for all given gff rows
get_a_counts <- function(bam_file_path,gff_rows, bam_files,names){
  reads_report <- data.frame() 
  for (gff_row in 1:nrow(gff_rows)){
    counts_frame <- get_a_counts_gff_row(bam_file_path, gff_rows[gff_row,], bam_files)
    counts_frame$gene_or_peak_name <- names[gff_row]
    reads_report <-rbind(reads_report,counts_frame )    
  }
  return(reads_report)
}


get_a_counts_gff_row <- function(bam_file_path,peak, bam_files){
  print(peak)
  if (peak[,"Orientation"]== "-"){
    ori <- TRUE    
  }
  else{
    ori <- FALSE
  }
  bam_frame <- data.frame()
  for (bam_file in bam_files){
    full_file_path <-paste(bam_file_path,bam_files, sep ="")
    
    param <- ScanBamParam(what=c('qname','pos','qwidth','strand'),
                          tag=c('AN','AD'),flag=scanBamFlag(isMinusStrand=ori) , 
                          which=GRanges(peak [,'Chromosome'],IRanges(
                          peak[,'Peak Start'], peak[,'Peak End'] )))
    #Grabs reads overlapping the range specified by the gff row
    result <- scanBam (full_file_path , param = param, isMinusStrand = ori)
    
    
    single_bam_frame <-  data.frame(result) 
    colnames(single_bam_frame)<- c("qname", "strand", "pos", 
                                   "width", "number_of_as", "number_of_ad_bases")
    #If the read is on the forward strand, add width to pos to obtain 3' end. 
    if (ori == FALSE ){
      single_bam_frame$pos <- single_bam_frame$pos+ single_bam_frame$width
    }    
    bam_frame <- rbind(bam_frame,single_bam_frame)
    
  }  
  return(bam_frame)
}



